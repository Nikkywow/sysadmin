# Практическое задание 2.5.1. Основы Bash (vo_HW)
# ЧАСТЬ 1.
## 1. Мониторинг активных процессов с использованием
```
ps aux | sort -nrk 3,3 | awk '{print $1, $3, $11}' > system_monitoring.txt
```
* ps aux — выводит все процессы с детальной информацией.
* sort -nrk 3,3 — сортирует по третьему столбцу (использование процессором, поле %CPU) в порядке убывания.
* awk '{print $1, $3, $11}' — выводит имя пользователя, процент использования процессора и команду (имя процесса).
* system_monitoring.txt — записывает результат в файл.

## 2. Сравнение содержимого двух директорий с использованием find, sort, и diff
```
diff <(find /path/to/dir1 -type f | sort) <(find /path/to/dir2 -type f | sort) > directory_comparison.txt
```
* find /path/to/dir1 -type f — находит все файлы в первой директории.
* find /path/to/dir2 -type f — находит все файлы во второй директории.
* sort — сортирует список файлов.
* diff — сравнивает два отсортированных списка.
* directory_comparison.txt — записывает результат в файл.

## 3. Подсчет общего числа строк в текстовых файлах с использованием find, xargs, и wc
```
find /path/to/dir -type f -name "*.txt" | xargs wc -l | awk '{s+=$1} END {print s}'
```
* find /path/to/dir -type f -name "*.txt" — находит все .txt файлы в указанной директории.
* xargs wc -l — передает найденные файлы в команду wc -l, которая считает количество строк в каждом файле.
* awk '{s+=$1} END {print s}' — суммирует количество строк для всех файлов и выводит итоговый результат.

## 4. Мониторинг использования дискового пространства с использованием df, sort, и awk
```
df -h | sort -nrk 5 | awk '{print $1, $5, $6}' > disk_space_usage.txt
```
* df -h — показывает использование диска в удобном формате (с размерами в удобных единицах).
* sort -nrk 5 — сортирует по пятому столбцу (использование диска, поле %), в порядке убывания.
* awk '{print $1, $5, $6}' — выводит файловую систему, процент использования и точку монтирования.
* disk_space_usage.txt — записывает результат в файл.

## 5. Фильтрация строк с ключевым словом в лог-файлах, сортировка и архивация с использованием cat, grep, awk, sort и tar
```
cat /var/log/*.log | grep "keyword" | awk '{print $0}' | sort > filtered_logs.txt
tar -czf filtered_logs.tar.gz filtered_logs.txt
```
* cat /var/log/*.log — выводит содержимое всех лог-файлов в каталоге /var/log/.
* grep "keyword" — фильтрует строки, содержащие ключевое слово "keyword".
* awk '{print $0}' — выводит все строки (можно использовать для дополнительной обработки, если необходимо).
* sort — сортирует строки.
* filtered_logs.txt — записывает отфильтрованные и отсортированные строки в файл filtered_logs.txt.
* tar -czf filtered_logs.tar.gz filtered_logs.txt — архивирует файл filtered_logs.txt в формате .tar.gz.

# ЧАСТЬ 1.
## Скрипт 1: Проверка доступности хостов в локальной сети.
```
#!/bin/bash

# Список хостов (IP-адресов или доменных имен)
hosts=("192.168.1.1" "google.com" "example.com" "192.168.1.2")

# Инициализация счетчиков
reachable=0
unreachable=0

# Цикл для проверки каждого хоста
for host in "${hosts[@]}"
do
    # Пинг хоста (три попытки)
    ping -c 3 $host > /dev/null 2>&1

    # Проверка статуса команды ping
    if [ $? -eq 0 ]; then
        echo "Хост $host доступен"
        ((reachable++))
    else
        echo "Хост $host недоступен"
        ((unreachable++))
    fi
done

# Вывод итогов
echo ""
echo "Общее количество доступных хостов: $reachable"
echo "Общее количество недоступных хостов: $unreachable"
```
* В переменной hosts содержится список хостов, которые необходимо проверить.
* Скрипт использует цикл for для проверки каждого хоста с помощью команды ping -c 3, которая отправляет 3 пакета на каждый хост.
* Если команда ping выполняется успешно ($? -eq 0), то хост считается доступным. Если команда не выполняется успешно, хост считается недоступным.*
* В конце скрипт выводит общее количество доступных и недоступных хостов.

## Скрипт 2: Анализ лог-файлов на наличие ключевого слова.
```
#!/bin/bash

# Указываем директорию для поиска лог-файлов
directory="/var/log"

# Ключевое слово для поиска
keyword="ERROR"

# Инициализация общего счетчика строк с ключевым словом
total_count=0

# Цикл для обработки всех .log файлов в директории
for log_file in "$directory"/*.log
do
    # Проверка, что файл существует
    if [ -f "$log_file" ]; then
        # Подсчет строк с ключевым словом в текущем файле
        count=$(grep -i "$keyword" "$log_file" | wc -l)

        # Выводим информацию о текущем файле
        echo "Файл $log_file содержит $count строк с ключевым словом $keyword"

        # Добавляем к общему числу
        total_count=$((total_count + count))
    fi
done

# Вывод общего количества строк с ключевым словом
echo ""
echo "Общее количество строк с ключевым словом \"$keyword\" в директории $directory: $total_count"

```
* В переменной directory указывается путь к директории, где находятся лог-файлы.
* В переменной keyword задается ключевое слово, которое будет искать скрипт (например, "ERROR").
* Скрипт использует команду grep -i для поиска строк с ключевым словом в каждом .log файле (флаг -i делает поиск нечувствительным к регистру).
* С помощью wc -l подсчитывается количество строк с ключевым словом в каждом файле.
* В конце скрипт выводит общее количество строк с ключевым словом по всем лог-файлам в указанной директории.
